<html><head><title>uxn-unx</title></head><body><main><h1>uxn-unx</h1><p>or how to build an OS from scratch.</p><h2>6th of February, 2022</h2><p>The [uxn]/[varvara] concept looks beautiful as it is. Especially with <a href="https://wiki.xxiivv.com/site/paradise.html">paradise</a>, it asks not to bring there any of the conceptions one learned before.</p><blockquote><p>Make what you can, or what you want?</p></blockquote><p>As a unix-like systems engineer, I really miss fork/wait/kill in varvara, this way I could build something unix-like out of it.
Tho I'm still worried I just do things the way I learnt things should be. This approach works well in commercial world, sure. Would it work in the <em>world of art</em>?</p><p>In classic, monolithic, unix-like operating systems, there is always a process, and the way to create a process is to <code>fork</code> itself. Then the child would <code>exec</code> into new application, much like [launcher] in [varvara] can run another ROM. Arguments to the new app are passed inside the <code>syscall</code> and straight to the <code>int main(int argc, char *argv)</code>. Operating system there is no more that the library with the interfaces, <code>syscall</code>, protected behind interrupts.</p><p>Most of it can be done with [uxn]/[varvara] with its devices and vectors. </p><blockquote><p>You'd want to create a uxn app that handles the routing of vectors to loaded applications in memory. You'd have to devise a scheme for the application format if you're really keen on doing multi-tasking in uxn.</p></blockquote><p>This, however, poses a question yet to solve. [uxn] is supposed to run on top of some kind of CPU. [varvara] is supposed to run on top of some kind of OS. Therefore, </p><ul><li>do I want an OS inside the [uxn], self-hosted and handling device access; </li><li>or do I want an OS outside of [varvara], where [uxn] is the only runtime and the microkernel is just juggling devices and merely VMs.</li></ul></main></body></html>